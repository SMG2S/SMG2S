<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMG2S: parMatrixSparse&lt; T, S &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMG2S
   </div>
   <div id="projectbrief">Sparse Matrix Generator with Given Spectrum</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpar_matrix_sparse.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classpar_matrix_sparse-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parMatrixSparse&lt; T, S &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group6.html">Parallel Vector and Matrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class which defines a sparse matrix distributed across 1D MPI grid.  
 <a href="classpar_matrix_sparse.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="par_matrix_sparse_8hpp_source.html">parMatrixSparse.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f213554d719138b1cb50f5568b8324d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a9f213554d719138b1cb50f5568b8324d">parMatrixSparse</a> (<a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt; vec)</td></tr>
<tr class="memdesc:a9f213554d719138b1cb50f5568b8324d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor of <code><a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a></code>.  <a href="classpar_matrix_sparse.html#a9f213554d719138b1cb50f5568b8324d">More...</a><br /></td></tr>
<tr class="separator:a9f213554d719138b1cb50f5568b8324d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f5de325e56a07b466c5fcbf7cf7b01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ae2f5de325e56a07b466c5fcbf7cf7b01">parMatrixSparse</a> (<a class="el" href="classpar_vector_map.html">parVectorMap</a>&lt; S &gt; map)</td></tr>
<tr class="memdesc:ae2f5de325e56a07b466c5fcbf7cf7b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor of <code><a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a></code>.  <a href="classpar_matrix_sparse.html#ae2f5de325e56a07b466c5fcbf7cf7b01">More...</a><br /></td></tr>
<tr class="separator:ae2f5de325e56a07b466c5fcbf7cf7b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538d44bda79828de61301ef005fb175d"><td class="memItemLeft" align="right" valign="top"><a id="a538d44bda79828de61301ef005fb175d"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a538d44bda79828de61301ef005fb175d">GetNRows</a> ()</td></tr>
<tr class="memdesc:a538d44bda79828de61301ef005fb175d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows of local matrix on each MPI proc. <br /></td></tr>
<tr class="separator:a538d44bda79828de61301ef005fb175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6294885bbe02ec46c8d9fd126d9b1f4b"><td class="memItemLeft" align="right" valign="top"><a id="a6294885bbe02ec46c8d9fd126d9b1f4b"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a6294885bbe02ec46c8d9fd126d9b1f4b">GetNCols</a> ()</td></tr>
<tr class="memdesc:a6294885bbe02ec46c8d9fd126d9b1f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of columns of local matrix on each MPI proc <br  />
 <br /></td></tr>
<tr class="separator:a6294885bbe02ec46c8d9fd126d9b1f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cab8d6e4a440ce115e156e6e45165e"><td class="memItemLeft" align="right" valign="top"><a id="a78cab8d6e4a440ce115e156e6e45165e"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a78cab8d6e4a440ce115e156e6e45165e">GetNNzLoc</a> ()</td></tr>
<tr class="memdesc:a78cab8d6e4a440ce115e156e6e45165e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of non-zeros entries of local matrix on each MPI proc <br  />
 <br /></td></tr>
<tr class="separator:a78cab8d6e4a440ce115e156e6e45165e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c43a866f847d23047c73849658e6fb"><td class="memItemLeft" align="right" valign="top"><a id="a29c43a866f847d23047c73849658e6fb"></a>
<a class="el" href="classpar_vector_map.html">parVectorMap</a>&lt; S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a29c43a866f847d23047c73849658e6fb">GetMap</a> ()</td></tr>
<tr class="memdesc:a29c43a866f847d23047c73849658e6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classpar_vector_map.html" title="A class which determines the way to distribute a vector across MPI procs.">parVectorMap</a> object used to distribute sparse Matrix. <br /></td></tr>
<tr class="separator:a29c43a866f847d23047c73849658e6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2942dcef5d440c80caefbbaff0a23aa1"><td class="memItemLeft" align="right" valign="top"><a id="a2942dcef5d440c80caefbbaff0a23aa1"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a2942dcef5d440c80caefbbaff0a23aa1">GetLowerBound</a> ()</td></tr>
<tr class="memdesc:a2942dcef5d440c80caefbbaff0a23aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpar_matrix_sparse.html#acdb81ab5b09c5505cfef8f722bf4c8c1" title="the smallest index of row of a distributed matrix on each MPI proc">parMatrixSparse::lower_b</a>. <br /></td></tr>
<tr class="separator:a2942dcef5d440c80caefbbaff0a23aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086c55a3eb4270f20a435526602f77af"><td class="memItemLeft" align="right" valign="top"><a id="a086c55a3eb4270f20a435526602f77af"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a086c55a3eb4270f20a435526602f77af">GetUpperBound</a> ()</td></tr>
<tr class="memdesc:a086c55a3eb4270f20a435526602f77af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpar_matrix_sparse.html#a721a29f839670b21a2c5cbae1e6f63e3" title="upper_b-1 = the largest index of row of a distributed matrix on each MPI proc">parMatrixSparse::upper_b</a> <br  />
 <br /></td></tr>
<tr class="separator:a086c55a3eb4270f20a435526602f77af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fcdb4ef63be497dd60005b4b70747b"><td class="memItemLeft" align="right" valign="top"><a id="a06fcdb4ef63be497dd60005b4b70747b"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a06fcdb4ef63be497dd60005b4b70747b">GetComm</a> ()</td></tr>
<tr class="memdesc:a06fcdb4ef63be497dd60005b4b70747b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpar_matrix_sparse.html#a59618a6a5722018b0bfb7175cdbb5ffb" title="the working MPI communicator">parMatrixSparse::comm</a> <br  />
 <br /></td></tr>
<tr class="separator:a06fcdb4ef63be497dd60005b4b70747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe7bc5e5268a048ada04489a7eaf5b8"><td class="memItemLeft" align="right" valign="top"><a id="a0fe7bc5e5268a048ada04489a7eaf5b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a0fe7bc5e5268a048ada04489a7eaf5b8">GetProcId</a> ()</td></tr>
<tr class="memdesc:a0fe7bc5e5268a048ada04489a7eaf5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpar_matrix_sparse.html#acd6719016846484f9f6bb231ba8ee30f" title="rank of each MPI procs within the working MPI communicator">parMatrixSparse::ProcID</a> <br  />
 <br /></td></tr>
<tr class="separator:a0fe7bc5e5268a048ada04489a7eaf5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea39893383ebfb41960a9aa8d4fb500"><td class="memItemLeft" align="right" valign="top"><a id="a8ea39893383ebfb41960a9aa8d4fb500"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a8ea39893383ebfb41960a9aa8d4fb500">GetNProcs</a> ()</td></tr>
<tr class="memdesc:a8ea39893383ebfb41960a9aa8d4fb500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpar_matrix_sparse.html#a70d5f2110e7504f3efe73cb736d5edc4" title="number of MPI procs within the working MPI communicator">parMatrixSparse::nProcs</a> <br  />
 <br /></td></tr>
<tr class="separator:a8ea39893383ebfb41960a9aa8d4fb500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8731a9565eaaa93a8659efc2a8fb0395"><td class="memItemLeft" align="right" valign="top"><a id="a8731a9565eaaa93a8659efc2a8fb0395"></a>
std::map&lt; S, T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a8731a9565eaaa93a8659efc2a8fb0395">GetDynMatLoc</a> ()</td></tr>
<tr class="memdesc:a8731a9565eaaa93a8659efc2a8fb0395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="classpar_matrix_sparse.html#a5a5473f6b6ccd49fe12dc52fa79692cf" title="An array of std::map in which each map stores the column index and related non-zero entry value of ea...">parMatrixSparse::dynmat_loc</a>. <br /></td></tr>
<tr class="separator:a8731a9565eaaa93a8659efc2a8fb0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dfec92c954bb9f971fe5b7d3602b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ae4dfec92c954bb9f971fe5b7d3602b63">SetValueLocal</a> (S row, S col, T value)</td></tr>
<tr class="memdesc:ae4dfec92c954bb9f971fe5b7d3602b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a value to a distributed sparse matrix with a given local index on each MPI proc.  <a href="classpar_matrix_sparse.html#ae4dfec92c954bb9f971fe5b7d3602b63">More...</a><br /></td></tr>
<tr class="separator:ae4dfec92c954bb9f971fe5b7d3602b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e79eac88966456e56a71ed843bf1cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a24e79eac88966456e56a71ed843bf1cf">SetValuesLocal</a> (S nindex, S *rows, S *cols, T *values)</td></tr>
<tr class="memdesc:a24e79eac88966456e56a71ed843bf1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple values to a distributed sparse matrix with given multiple local indices on each MPI proc.  <a href="classpar_matrix_sparse.html#a24e79eac88966456e56a71ed843bf1cf">More...</a><br /></td></tr>
<tr class="separator:a24e79eac88966456e56a71ed843bf1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47bb2ea29d0371b8398b601b1a08b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#aa47bb2ea29d0371b8398b601b1a08b15">SetValue</a> (S row, S col, T value)</td></tr>
<tr class="memdesc:aa47bb2ea29d0371b8398b601b1a08b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a value to a distributed sparse matrix with a given global index on each MPI proc.  <a href="classpar_matrix_sparse.html#aa47bb2ea29d0371b8398b601b1a08b15">More...</a><br /></td></tr>
<tr class="separator:aa47bb2ea29d0371b8398b601b1a08b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c529eeecaf092bf9365b13ab6b957c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a6c529eeecaf092bf9365b13ab6b957c2">SetDiagonal</a> (<a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt; diag)</td></tr>
<tr class="memdesc:a6c529eeecaf092bf9365b13ab6b957c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the diagonal of a distributed sparse matrix with a given <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object.  <a href="classpar_matrix_sparse.html#a6c529eeecaf092bf9365b13ab6b957c2">More...</a><br /></td></tr>
<tr class="separator:a6c529eeecaf092bf9365b13ab6b957c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5348f032b62da8dde5f42062e6d5c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a8d5348f032b62da8dde5f42062e6d5c5">AddValueLocal</a> (S row, S col, T value)</td></tr>
<tr class="memdesc:a8d5348f032b62da8dde5f42062e6d5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to an entry of a distributed sparse matrix with a given local index on each MPI proc.  <a href="classpar_matrix_sparse.html#a8d5348f032b62da8dde5f42062e6d5c5">More...</a><br /></td></tr>
<tr class="separator:a8d5348f032b62da8dde5f42062e6d5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee73c4753fcd7988e394c1e5d9e3b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#acee73c4753fcd7988e394c1e5d9e3b9b">AddValue</a> (S row, S col, T value)</td></tr>
<tr class="memdesc:acee73c4753fcd7988e394c1e5d9e3b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to an entry of a distributed sparse matrix with a given global index on each MPI proc.  <a href="classpar_matrix_sparse.html#acee73c4753fcd7988e394c1e5d9e3b9b">More...</a><br /></td></tr>
<tr class="separator:acee73c4753fcd7988e394c1e5d9e3b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a833ce54055a73d9547286044f445d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a56a833ce54055a73d9547286044f445d">GetValueLocal</a> (S row, S col)</td></tr>
<tr class="memdesc:a56a833ce54055a73d9547286044f445d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a value of an entry of a distributed sparse matrix with a given local index on each MPI proc.  <a href="classpar_matrix_sparse.html#a56a833ce54055a73d9547286044f445d">More...</a><br /></td></tr>
<tr class="separator:a56a833ce54055a73d9547286044f445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76779e1aff143cfab2db06f8efa478cb"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a76779e1aff143cfab2db06f8efa478cb">GetValue</a> (S row, S col)</td></tr>
<tr class="memdesc:a76779e1aff143cfab2db06f8efa478cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a value to an entry of a distributed sparse matrix with a given global index on each MPI proc.  <a href="classpar_matrix_sparse.html#a76779e1aff143cfab2db06f8efa478cb">More...</a><br /></td></tr>
<tr class="separator:a76779e1aff143cfab2db06f8efa478cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3a5ad83ac84790278edca18f78b292"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#abf3a5ad83ac84790278edca18f78b292">MatScale</a> (T scale)</td></tr>
<tr class="memdesc:abf3a5ad83ac84790278edca18f78b292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an operation <code>A = scale * A</code>, in which <code>scale</code> is a scalar.  <a href="classpar_matrix_sparse.html#abf3a5ad83ac84790278edca18f78b292">More...</a><br /></td></tr>
<tr class="separator:abf3a5ad83ac84790278edca18f78b292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a73d1822367fd478c205a2f64626fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a4a73d1822367fd478c205a2f64626fdc">MatAXPY</a> (<a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt; X, T scale)</td></tr>
<tr class="memdesc:a4a73d1822367fd478c205a2f64626fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <code>A = A + scale * X</code>  <a href="classpar_matrix_sparse.html#a4a73d1822367fd478c205a2f64626fdc">More...</a><br /></td></tr>
<tr class="separator:a4a73d1822367fd478c205a2f64626fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9afdf197c96c0f513ccbab14c7b775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ace9afdf197c96c0f513ccbab14c7b775">MatAYPX</a> (<a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt; X, T scale)</td></tr>
<tr class="memdesc:ace9afdf197c96c0f513ccbab14c7b775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <code>A = scale * A + X</code>  <a href="classpar_matrix_sparse.html#ace9afdf197c96c0f513ccbab14c7b775">More...</a><br /></td></tr>
<tr class="separator:ace9afdf197c96c0f513ccbab14c7b775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d50f5934c8f02b69ecc881fba409c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a8d50f5934c8f02b69ecc881fba409c9a">initMat</a> (S diag_l, S diag_u, Base&lt; T &gt; scale, T shift, Base&lt; T &gt; sparsity)</td></tr>
<tr class="memdesc:a8d50f5934c8f02b69ecc881fba409c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">filling the lower part of matrix between diagonal of offset <code>diag_l</code> and diagonal of offset <code>diag_u</code> with random values <code>scale * rnd + shift</code> where <code>rnd</code> is a randomly generated value between <code>0</code> and <code>1</code>  <a href="classpar_matrix_sparse.html#a8d50f5934c8f02b69ecc881fba409c9a">More...</a><br /></td></tr>
<tr class="separator:a8d50f5934c8f02b69ecc881fba409c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e63e21dd772646d95e8425c2991ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ae0e63e21dd772646d95e8425c2991ca8">initMat</a> (S diag_l, S diag_u)</td></tr>
<tr class="memdesc:ae0e63e21dd772646d95e8425c2991ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">filling the lower part of matrix between diagonal of offset <code>diag_l</code> and diagonal of offset <code>diag_u</code> with random values <code>rnd</code>, which is a randomly generated value between <code>0</code> and <code>1</code>  <a href="classpar_matrix_sparse.html#ae0e63e21dd772646d95e8425c2991ca8">More...</a><br /></td></tr>
<tr class="separator:ae0e63e21dd772646d95e8425c2991ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6146fc6b73321fd7f4be8c062ce9de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a9f6146fc6b73321fd7f4be8c062ce9de">setSpecNonHerm</a> (<a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt; spectrum)</td></tr>
<tr class="memdesc:a9f6146fc6b73321fd7f4be8c062ce9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a given spectrum onto a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object for constructing a non-Hermitian matrix.  <a href="classpar_matrix_sparse.html#a9f6146fc6b73321fd7f4be8c062ce9de">More...</a><br /></td></tr>
<tr class="separator:a9f6146fc6b73321fd7f4be8c062ce9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab03a6492b2dea44d72ff35e630b6b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a1ab03a6492b2dea44d72ff35e630b6b4">setSpecNonSymm</a> (<a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt; spectrum)</td></tr>
<tr class="memdesc:a1ab03a6492b2dea44d72ff35e630b6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a given spectrum (all eigenvalues are in real scalars) onto a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object for constructing a non-Symmetric matrix.  <a href="classpar_matrix_sparse.html#a1ab03a6492b2dea44d72ff35e630b6b4">More...</a><br /></td></tr>
<tr class="separator:a1ab03a6492b2dea44d72ff35e630b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340f7dc812f5ecc0be910c9de9ae3449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a340f7dc812f5ecc0be910c9de9ae3449">setSpecNonSymmCmplx</a> (<a class="el" href="classpar_vector.html">parVector</a>&lt; std::complex&lt; Base&lt; T &gt;&gt;, S &gt; spectrum)</td></tr>
<tr class="memdesc:a340f7dc812f5ecc0be910c9de9ae3449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a given spectrum (all eigenvalues can be in real scalars or appear as pairs of conjugate complex scalars) onto a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object for constructing a non-Symmetric matrix.  <a href="classpar_matrix_sparse.html#a340f7dc812f5ecc0be910c9de9ae3449">More...</a><br /></td></tr>
<tr class="separator:a340f7dc812f5ecc0be910c9de9ae3449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06caa3df2e238ba185b8734b72ea2b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#af06caa3df2e238ba185b8734b72ea2b8">updateNnz</a> ()</td></tr>
<tr class="memdesc:af06caa3df2e238ba185b8734b72ea2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly re-compute the number of nnz on each MPI proc.  <a href="classpar_matrix_sparse.html#af06caa3df2e238ba185b8734b72ea2b8">More...</a><br /></td></tr>
<tr class="separator:af06caa3df2e238ba185b8734b72ea2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ad3261a1680156f68a23cd21efa1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a62ad3261a1680156f68a23cd21efa1cb">copy</a> (<a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt; X)</td></tr>
<tr class="memdesc:a62ad3261a1680156f68a23cd21efa1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate from another <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object.  <a href="classpar_matrix_sparse.html#a62ad3261a1680156f68a23cd21efa1cb">More...</a><br /></td></tr>
<tr class="separator:a62ad3261a1680156f68a23cd21efa1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65615fca96ae5df7527a0db7feefc87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ae65615fca96ae5df7527a0db7feefc87">rmZeros</a> ()</td></tr>
<tr class="memdesc:ae65615fca96ae5df7527a0db7feefc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly remove all the zeros of <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object.  <a href="classpar_matrix_sparse.html#ae65615fca96ae5df7527a0db7feefc87">More...</a><br /></td></tr>
<tr class="separator:ae65615fca96ae5df7527a0db7feefc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f8ba9c2c98d2047c6c439c609e8dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a235f8ba9c2c98d2047c6c439c609e8dc">MA</a> (<a class="el" href="class_nilpotent.html">Nilpotent</a>&lt; S &gt; nilp)</td></tr>
<tr class="memdesc:a235f8ba9c2c98d2047c6c439c609e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <code>M*A</code>, in which <code>A</code> is a nilpotent matrix.  <a href="classpar_matrix_sparse.html#a235f8ba9c2c98d2047c6c439c609e8dc">More...</a><br /></td></tr>
<tr class="separator:a235f8ba9c2c98d2047c6c439c609e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edda48d34af014d4d0a6f16501c0eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a0edda48d34af014d4d0a6f16501c0eed">AM</a> (<a class="el" href="class_nilpotent.html">Nilpotent</a>&lt; S &gt; nilp)</td></tr>
<tr class="memdesc:a0edda48d34af014d4d0a6f16501c0eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <code>A*M</code>, in which <code>A</code> is a nilpotent matrix.  <a href="classpar_matrix_sparse.html#a0edda48d34af014d4d0a6f16501c0eed">More...</a><br /></td></tr>
<tr class="separator:a0edda48d34af014d4d0a6f16501c0eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e67548fc7e3a467cc3fe1669df61dc"><td class="memItemLeft" align="right" valign="top"><a id="ab4e67548fc7e3a467cc3fe1669df61dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ab4e67548fc7e3a467cc3fe1669df61dc">ZeroEntries</a> ()</td></tr>
<tr class="memdesc:ab4e67548fc7e3a467cc3fe1669df61dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all the entries a sparse matrix to be zeros, but keep the sparsity structure as it is. <br /></td></tr>
<tr class="separator:ab4e67548fc7e3a467cc3fe1669df61dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259fb7cf6eb8e850cb4512f1b99cdea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_matrix_c_s_r.html">MatrixCSR</a>&lt; T, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a259fb7cf6eb8e850cb4512f1b99cdea8">ConvertToCSR</a> ()</td></tr>
<tr class="memdesc:a259fb7cf6eb8e850cb4512f1b99cdea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> with dynamic memory into a distributed CSR matrix.  <a href="classpar_matrix_sparse.html#a259fb7cf6eb8e850cb4512f1b99cdea8">More...</a><br /></td></tr>
<tr class="separator:a259fb7cf6eb8e850cb4512f1b99cdea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4649b90d3f6535b13a9a2796529d61e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a4649b90d3f6535b13a9a2796529d61e4">show</a> ()</td></tr>
<tr class="memdesc:a4649b90d3f6535b13a9a2796529d61e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display multiple information of a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object.  <a href="classpar_matrix_sparse.html#a4649b90d3f6535b13a9a2796529d61e4">More...</a><br /></td></tr>
<tr class="separator:a4649b90d3f6535b13a9a2796529d61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7d0f0c8cb5aaa324e404d438b039ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a0f7d0f0c8cb5aaa324e404d438b039ba">MatView</a> ()</td></tr>
<tr class="memdesc:a0f7d0f0c8cb5aaa324e404d438b039ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object in a distributed COO format.  <a href="classpar_matrix_sparse.html#a0f7d0f0c8cb5aaa324e404d438b039ba">More...</a><br /></td></tr>
<tr class="separator:a0f7d0f0c8cb5aaa324e404d438b039ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9646d867bd86ae295424adbac5123d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a9646d867bd86ae295424adbac5123d4c">MatView</a> (std::string matName)</td></tr>
<tr class="memdesc:a9646d867bd86ae295424adbac5123d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object in a distributed COO format with matrix name indicated at the starting point of each line.  <a href="classpar_matrix_sparse.html#a9646d867bd86ae295424adbac5123d4c">More...</a><br /></td></tr>
<tr class="separator:a9646d867bd86ae295424adbac5123d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bb25445d859997c267d01028de2457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ae0bb25445d859997c267d01028de2457">writeToMatrixMarket</a> (std::string file_name)</td></tr>
<tr class="memdesc:ae0bb25445d859997c267d01028de2457"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel IO to write a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object into a file of MatrixMarket format.  <a href="classpar_matrix_sparse.html#ae0bb25445d859997c267d01028de2457">More...</a><br /></td></tr>
<tr class="separator:ae0bb25445d859997c267d01028de2457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2106220d853b165ff53a4a643fc47d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#ae2106220d853b165ff53a4a643fc47d9">writeToMatrixMarketCmplx</a> (std::string file_name)</td></tr>
<tr class="memdesc:ae2106220d853b165ff53a4a643fc47d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel IO to write a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object with complex scalar into a file of MatrixMarket format.  <a href="classpar_matrix_sparse.html#ae2106220d853b165ff53a4a643fc47d9">More...</a><br /></td></tr>
<tr class="separator:ae2106220d853b165ff53a4a643fc47d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5a5473f6b6ccd49fe12dc52fa79692cf"><td class="memItemLeft" align="right" valign="top"><a id="a5a5473f6b6ccd49fe12dc52fa79692cf"></a>
std::map&lt; S, T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a5a5473f6b6ccd49fe12dc52fa79692cf">dynmat_loc</a></td></tr>
<tr class="memdesc:a5a5473f6b6ccd49fe12dc52fa79692cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of <code>std::map</code> in which each map stores the column index and related non-zero entry value of each row. <br /></td></tr>
<tr class="separator:a5a5473f6b6ccd49fe12dc52fa79692cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2a68d7981fd0336bca4cb24fd08c20"><td class="memItemLeft" align="right" valign="top"><a id="a0d2a68d7981fd0336bca4cb24fd08c20"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a0d2a68d7981fd0336bca4cb24fd08c20">ncols</a></td></tr>
<tr class="memdesc:a0d2a68d7981fd0336bca4cb24fd08c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns of local matrix on each MPI proc <br /></td></tr>
<tr class="separator:a0d2a68d7981fd0336bca4cb24fd08c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d69e2e053853a573ad9ed084afbdcd"><td class="memItemLeft" align="right" valign="top"><a id="aa5d69e2e053853a573ad9ed084afbdcd"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#aa5d69e2e053853a573ad9ed084afbdcd">nrows</a></td></tr>
<tr class="memdesc:aa5d69e2e053853a573ad9ed084afbdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows of local matrix on each MPI proc <br /></td></tr>
<tr class="separator:aa5d69e2e053853a573ad9ed084afbdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cfc1af77466f3324c308c9d201b958"><td class="memItemLeft" align="right" valign="top"><a id="a63cfc1af77466f3324c308c9d201b958"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a63cfc1af77466f3324c308c9d201b958">nnz_loc</a></td></tr>
<tr class="memdesc:a63cfc1af77466f3324c308c9d201b958"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of non-zero entries of local matrix on each MPI proc <br /></td></tr>
<tr class="separator:a63cfc1af77466f3324c308c9d201b958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e3b5910c4671015f960fca23228aae"><td class="memItemLeft" align="right" valign="top"><a id="a14e3b5910c4671015f960fca23228aae"></a>
<a class="el" href="classpar_vector_map.html">parVectorMap</a>&lt; S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a14e3b5910c4671015f960fca23228aae">index_map</a></td></tr>
<tr class="memdesc:a14e3b5910c4671015f960fca23228aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="classpar_vector_map.html" title="A class which determines the way to distribute a vector across MPI procs.">parVectorMap</a> object used to distribute the global matrix across 1D MPI grid <br /></td></tr>
<tr class="separator:a14e3b5910c4671015f960fca23228aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb81ab5b09c5505cfef8f722bf4c8c1"><td class="memItemLeft" align="right" valign="top"><a id="acdb81ab5b09c5505cfef8f722bf4c8c1"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#acdb81ab5b09c5505cfef8f722bf4c8c1">lower_b</a></td></tr>
<tr class="memdesc:acdb81ab5b09c5505cfef8f722bf4c8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the smallest index of row of a distributed matrix on each MPI proc <br /></td></tr>
<tr class="separator:acdb81ab5b09c5505cfef8f722bf4c8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721a29f839670b21a2c5cbae1e6f63e3"><td class="memItemLeft" align="right" valign="top"><a id="a721a29f839670b21a2c5cbae1e6f63e3"></a>
S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a721a29f839670b21a2c5cbae1e6f63e3">upper_b</a></td></tr>
<tr class="memdesc:a721a29f839670b21a2c5cbae1e6f63e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">upper_b-1 = the largest index of row of a distributed matrix on each MPI proc <br /></td></tr>
<tr class="separator:a721a29f839670b21a2c5cbae1e6f63e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59618a6a5722018b0bfb7175cdbb5ffb"><td class="memItemLeft" align="right" valign="top"><a id="a59618a6a5722018b0bfb7175cdbb5ffb"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a59618a6a5722018b0bfb7175cdbb5ffb">comm</a></td></tr>
<tr class="memdesc:a59618a6a5722018b0bfb7175cdbb5ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the working MPI communicator <br /></td></tr>
<tr class="separator:a59618a6a5722018b0bfb7175cdbb5ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6719016846484f9f6bb231ba8ee30f"><td class="memItemLeft" align="right" valign="top"><a id="acd6719016846484f9f6bb231ba8ee30f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#acd6719016846484f9f6bb231ba8ee30f">ProcID</a></td></tr>
<tr class="memdesc:acd6719016846484f9f6bb231ba8ee30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">rank of each MPI procs within the working MPI communicator <br  />
 <br /></td></tr>
<tr class="separator:acd6719016846484f9f6bb231ba8ee30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d5f2110e7504f3efe73cb736d5edc4"><td class="memItemLeft" align="right" valign="top"><a id="a70d5f2110e7504f3efe73cb736d5edc4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_matrix_sparse.html#a70d5f2110e7504f3efe73cb736d5edc4">nProcs</a></td></tr>
<tr class="memdesc:a70d5f2110e7504f3efe73cb736d5edc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of MPI procs within the working MPI communicator <br /></td></tr>
<tr class="separator:a70d5f2110e7504f3efe73cb736d5edc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename S&gt;<br />
class parMatrixSparse&lt; T, S &gt;</h3>

<p>A class which defines a sparse matrix distributed across 1D MPI grid. </p>
<ul>
<li>This class can be constructed with a given <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> with the same distribution scheme.</li>
<li>This class can be constructed with a distribution scheme by a given <a class="el" href="classpar_vector_map.html" title="A class which determines the way to distribute a vector across MPI procs.">parVectorMap</a> object.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>describes the scalar types of the entries of a sparse matrix. <br  />
 </td></tr>
    <tr><td class="paramname">S</td><td>type of integer to describes the dimension of vector to be generated. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f213554d719138b1cb50f5568b8324d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f213554d719138b1cb50f5568b8324d">&#9670;&nbsp;</a></span>parMatrixSparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::<a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constructor of <code><a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>a given <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a>, a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object is constructed with the same distribution scheme of <code>vec</code></td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="classpar_matrix_sparse.html#a5a5473f6b6ccd49fe12dc52fa79692cf" title="An array of std::map in which each map stores the column index and related non-zero entry value of ea...">parMatrixSparse::dynmat_loc</a> is not allocated. </li>
</ul>

</div>
</div>
<a id="ae2f5de325e56a07b466c5fcbf7cf7b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f5de325e56a07b466c5fcbf7cf7b01">&#9670;&nbsp;</a></span>parMatrixSparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::<a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_vector_map.html">parVectorMap</a>&lt; S &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constructor of <code><a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>the distribution scheme determined by this object of type <a class="el" href="classpar_vector_map.html" title="A class which determines the way to distribute a vector across MPI procs.">parVectorMap</a></td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><a class="el" href="classpar_matrix_sparse.html#a5a5473f6b6ccd49fe12dc52fa79692cf" title="An array of std::map in which each map stores the column index and related non-zero entry value of ea...">parMatrixSparse::dynmat_loc</a> is not allocated. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acee73c4753fcd7988e394c1e5d9e3b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee73c4753fcd7988e394c1e5d9e3b9b">&#9670;&nbsp;</a></span>AddValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::AddValue </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to an entry of a distributed sparse matrix with a given global index on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the global index of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the global index of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the scalar to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d5348f032b62da8dde5f42062e6d5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5348f032b62da8dde5f42062e6d5c5">&#9670;&nbsp;</a></span>AddValueLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::AddValueLocal </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to an entry of a distributed sparse matrix with a given local index on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the local index of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the local index of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the scalar to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0edda48d34af014d4d0a6f16501c0eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edda48d34af014d4d0a6f16501c0eed">&#9670;&nbsp;</a></span>AM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt; <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::AM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nilpotent.html">Nilpotent</a>&lt; S &gt;&#160;</td>
          <td class="paramname"><em>nilp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform <code>A*M</code>, in which <code>A</code> is a nilpotent matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nilp</td><td>a <a class="el" href="class_nilpotent.html" title="A class which determines the information of a nilpotent matrix.">Nilpotent</a><s> object which determines a nilpotent matrix </s></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a259fb7cf6eb8e850cb4512f1b99cdea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259fb7cf6eb8e850cb4512f1b99cdea8">&#9670;&nbsp;</a></span>ConvertToCSR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_matrix_c_s_r.html">MatrixCSR</a>&lt; T, S &gt; <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::ConvertToCSR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> with dynamic memory into a distributed CSR matrix. </p>
<ul>
<li>Attention, after the converting, any operations on the matrix can be implicity updated on the CSR matrix </li>
</ul>

</div>
</div>
<a id="a62ad3261a1680156f68a23cd21efa1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ad3261a1680156f68a23cd21efa1cb">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate from another <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>another <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object to be duplicated with a same distribution scheme </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76779e1aff143cfab2db06f8efa478cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76779e1aff143cfab2db06f8efa478cb">&#9670;&nbsp;</a></span>GetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::GetValue </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a value to an entry of a distributed sparse matrix with a given global index on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the global index of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the global index of column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56a833ce54055a73d9547286044f445d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a833ce54055a73d9547286044f445d">&#9670;&nbsp;</a></span>GetValueLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::GetValueLocal </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a value of an entry of a distributed sparse matrix with a given local index on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the local index of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the local index of column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0e63e21dd772646d95e8425c2991ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e63e21dd772646d95e8425c2991ca8">&#9670;&nbsp;</a></span>initMat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::<a class="el" href="structinit_mat.html">initMat</a> </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>diag_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>diag_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>filling the lower part of matrix between diagonal of offset <code>diag_l</code> and diagonal of offset <code>diag_u</code> with random values <code>rnd</code>, which is a randomly generated value between <code>0</code> and <code>1</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_l</td><td>the offset of lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_u</td><td>the offset of lower diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d50f5934c8f02b69ecc881fba409c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d50f5934c8f02b69ecc881fba409c9a">&#9670;&nbsp;</a></span>initMat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::<a class="el" href="structinit_mat.html">initMat</a> </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>diag_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>diag_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base&lt; T &gt;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base&lt; T &gt;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>filling the lower part of matrix between diagonal of offset <code>diag_l</code> and diagonal of offset <code>diag_u</code> with random values <code>scale * rnd + shift</code> where <code>rnd</code> is a randomly generated value between <code>0</code> and <code>1</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_l</td><td>the offset of lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_u</td><td>the offset of lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>a scalar to be multiplied on the randomly generated value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>a scalar to be added on the randomly generated value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsity</td><td>the probability that a entry in the range set to be zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a235f8ba9c2c98d2047c6c439c609e8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235f8ba9c2c98d2047c6c439c609e8dc">&#9670;&nbsp;</a></span>MA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt; <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::MA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nilpotent.html">Nilpotent</a>&lt; S &gt;&#160;</td>
          <td class="paramname"><em>nilp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform <code>M*A</code>, in which <code>A</code> is a nilpotent matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nilp</td><td>a <a class="el" href="class_nilpotent.html" title="A class which determines the information of a nilpotent matrix.">Nilpotent</a><s> object which determines a nilpotent matrix </s></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a73d1822367fd478c205a2f64626fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a73d1822367fd478c205a2f64626fdc">&#9670;&nbsp;</a></span>MatAXPY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::MatAXPY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform <code>A = A + scale * X</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>another <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object with a same distribution scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>the scalar to be multiplied on <code>X</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace9afdf197c96c0f513ccbab14c7b775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9afdf197c96c0f513ccbab14c7b775">&#9670;&nbsp;</a></span>MatAYPX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::MatAYPX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform <code>A = scale * A + X</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>another <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object with a same distribution scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>the scalar to be multiplied on <code>A</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf3a5ad83ac84790278edca18f78b292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3a5ad83ac84790278edca18f78b292">&#9670;&nbsp;</a></span>MatScale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::MatScale </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an operation <code>A = scale * A</code>, in which <code>scale</code> is a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>the scalar to be multiplied on the distributed sparse matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f7d0f0c8cb5aaa324e404d438b039ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7d0f0c8cb5aaa324e404d438b039ba">&#9670;&nbsp;</a></span>MatView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::MatView</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object in a distributed COO format. </p>
<ul>
<li>This is a distributed function that each MPI proc can only display the piece of local matrix on itself. </li>
</ul>

</div>
</div>
<a id="a9646d867bd86ae295424adbac5123d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9646d867bd86ae295424adbac5123d4c">&#9670;&nbsp;</a></span>MatView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::MatView </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>matName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object in a distributed COO format with matrix name indicated at the starting point of each line. </p>
<ul>
<li>This is a distributed function that each MPI proc can only display the piece of local matrix on itself. </li>
</ul>

</div>
</div>
<a id="ae65615fca96ae5df7527a0db7feefc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65615fca96ae5df7527a0db7feefc87">&#9670;&nbsp;</a></span>rmZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::rmZeros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly remove all the zeros of <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object. </p>
<ul>
<li>This member function is introduced in case any matrix operation would introduce some (explicit) zeros. </li>
</ul>

</div>
</div>
<a id="a6c529eeecaf092bf9365b13ab6b957c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c529eeecaf092bf9365b13ab6b957c2">&#9670;&nbsp;</a></span>SetDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::SetDiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>diag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the diagonal of a distributed sparse matrix with a given <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag</td><td>a given <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object to be set on the diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6146fc6b73321fd7f4be8c062ce9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6146fc6b73321fd7f4be8c062ce9de">&#9670;&nbsp;</a></span>setSpecNonHerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::setSpecNonHerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>spectrum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a given spectrum onto a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object for constructing a non-Hermitian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spectrum</td><td>a <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object which stores the given spectrum in complex scalars</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This operation is naturally in parallel since the spectrum is stored in a <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object</li>
<li>Attention, this member function works only with complex scalar </li>
</ul>

</div>
</div>
<a id="a1ab03a6492b2dea44d72ff35e630b6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab03a6492b2dea44d72ff35e630b6b4">&#9670;&nbsp;</a></span>setSpecNonSymm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::setSpecNonSymm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_vector.html">parVector</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>spectrum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a given spectrum (all eigenvalues are in real scalars) onto a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object for constructing a non-Symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spectrum</td><td>a <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object which stores the given spectrum in real scalars</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This operation is naturally in parallel since the spectrum is stored in a <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object</li>
<li>Attention, this member function works only with real scalar </li>
</ul>

</div>
</div>
<a id="a340f7dc812f5ecc0be910c9de9ae3449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340f7dc812f5ecc0be910c9de9ae3449">&#9670;&nbsp;</a></span>setSpecNonSymmCmplx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::setSpecNonSymmCmplx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpar_vector.html">parVector</a>&lt; std::complex&lt; Base&lt; T &gt;&gt;, S &gt;&#160;</td>
          <td class="paramname"><em>spectrum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a given spectrum (all eigenvalues can be in real scalars or appear as pairs of conjugate complex scalars) onto a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object for constructing a non-Symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spectrum</td><td>a <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object which stores the given spectrum with conjugate eigenvalues</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This operation is naturally in parallel since the spectrum is stored in a <a class="el" href="classpar_vector.html" title="A class which defines a vector distributed across 1D MPI grid.">parVector</a> object</li>
<li>Attention, for each conjugate pairs of eigenvalues, they should be placed one after another, they cannot be placed in a random order. Before setting the spectrum to the matrix, the spectrum will be checked if it satisfies this condition </li>
</ul>

</div>
</div>
<a id="aa47bb2ea29d0371b8398b601b1a08b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47bb2ea29d0371b8398b601b1a08b15">&#9670;&nbsp;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::SetValue </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a value to a distributed sparse matrix with a given global index on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the global index of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the global index of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the scalar to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4dfec92c954bb9f971fe5b7d3602b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dfec92c954bb9f971fe5b7d3602b63">&#9670;&nbsp;</a></span>SetValueLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::SetValueLocal </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a value to a distributed sparse matrix with a given local index on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the local index of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the local index of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the scalar to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e79eac88966456e56a71ed843bf1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e79eac88966456e56a71ed843bf1cf">&#9670;&nbsp;</a></span>SetValuesLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::SetValuesLocal </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>nindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multiple values to a distributed sparse matrix with given multiple local indices on each MPI proc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nindex</td><td>number of values to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>an array storing multiple local indices of row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>an array storing multiple local indices of column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>an array storing multiple scalars to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4649b90d3f6535b13a9a2796529d61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4649b90d3f6535b13a9a2796529d61e4">&#9670;&nbsp;</a></span>show()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::show</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display multiple information of a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object. </p>
<ul>
<li>number of rows of local matrix</li>
<li>number of columns of local matrix</li>
<li>number of nnz of local matrix</li>
<li><a class="el" href="classpar_matrix_sparse.html#acdb81ab5b09c5505cfef8f722bf4c8c1" title="the smallest index of row of a distributed matrix on each MPI proc">parMatrixSparse::lower_b</a></li>
<li><a class="el" href="classpar_matrix_sparse.html#a721a29f839670b21a2c5cbae1e6f63e3" title="upper_b-1 = the largest index of row of a distributed matrix on each MPI proc">parMatrixSparse::upper_b</a> </li>
</ul>

</div>
</div>
<a id="af06caa3df2e238ba185b8734b72ea2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06caa3df2e238ba185b8734b72ea2b8">&#9670;&nbsp;</a></span>updateNnz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::updateNnz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly re-compute the number of nnz on each MPI proc. </p>
<ul>
<li>This member function is introduced in case any matrix operation would failed to update the number of nnz </li>
</ul>

</div>
</div>
<a id="ae0bb25445d859997c267d01028de2457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bb25445d859997c267d01028de2457">&#9670;&nbsp;</a></span>writeToMatrixMarket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::writeToMatrixMarket </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel IO to write a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object into a file of MatrixMarket format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>the path and file name to write into</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Attention, this method works only of sparse matrix with real scalar (<code>double</code>, <code>float</code>...) </li>
</ul>

</div>
</div>
<a id="ae2106220d853b165ff53a4a643fc47d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2106220d853b165ff53a4a643fc47d9">&#9670;&nbsp;</a></span>writeToMatrixMarketCmplx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a>&lt; T, S &gt;::writeToMatrixMarketCmplx </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel IO to write a <a class="el" href="classpar_matrix_sparse.html" title="A class which defines a sparse matrix distributed across 1D MPI grid.">parMatrixSparse</a> object with complex scalar into a file of MatrixMarket format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>the path and file name to write into</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Attention, this method works only of sparse matrix with scalar scalar (std::complex&lt;double&gt;, std::complex&lt;float&gt;...) </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/parMatrix/<a class="el" href="par_matrix_sparse_8hpp_source.html">parMatrixSparse.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classpar_matrix_sparse.html">parMatrixSparse</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
